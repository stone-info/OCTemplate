<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>example-vue</title>
  <!--
  <meta content="no" name="apple-mobile-web-app-capable">
    删除默认的苹果工具栏和菜单栏。
    需要显示工具栏和菜单栏时，不需要添加，默认值为no，即正常显示。如果content设置为yes，
    Web应用会以全屏模式运行，可以通过只读属性window.navigator.standalone来确定网页是否以全屏模式显示。

  -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <!--
    “apple-mobile-web-app-status-bar-style”作用是控制状态栏显示样式
    （默认样）
     具体效果如下：
      status-bar-style:black
  -->
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <!--
    https://blog.csdn.net/CPPCPPCPPCPP/article/details/78649328
    <META NAME=”ROBOTS” CONTENT=”NOINDEX,NOFOLLOW”>：不许抓取本页，也不许顺着本页抓取索引别的链接。
    <META NAME=”ROBOTS” CONTENT=”NOINDEX,NOFOLLOW”>的形式的话，可以写成：
　  <META NAME=”ROBOTS” CONTENT=”NONE”>
  -->
  <meta name="robots" content="none">

  <!--<meta name="viewport" content="width=device-width,initial-scale=1.0">-->
  <meta name="viewport" content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <!--
  https://kinglyhum.iteye.com/blog/827807

  Pragma(cache模式)
    说明：是用于设定禁止浏览器从本地机的缓存中调阅页面内容，设定后一旦离开网页就无法从Cache中再调出
    用法：
    ＜meta http-equiv="Pragma" content="no-cache"＞
    注意：这样设定，访问者将无法脱机浏览。
  -->
  <meta http-equiv="pragma" content="no-cache">
  <!--
  清除缓存（再访问这个网站要重新下载！）
    <meta http-equiv="cache-control" content="no-cache">
  -->
  <meta http-equiv="cache-control" content="no-cache">
  <!--
  设定网页的到期时间
    <meta http-equiv="expires" content="0">
  -->
  <meta http-equiv="expires" content="0">
  <!--
    如果资源是html页面，可以设置 | 也可以设置为 * 表示该资源谁都可以用
      <meta http-equiv="Access-Control-Allow-Origin" content="*">
  -->
  <meta http-equiv="Access-Control-Allow-Origin" content="*">

  <script src="static/js/hlog.js" type="text/javascript"></script>

  <!--<script type="text/javascript">-->
  <!--var orignalSetItem   = localStorage.setItem-->
  <!--localStorage.setItem = function (key, newValue) {-->
  <!--var setItemEvent      = new Event('setItemEvent')-->
  <!--setItemEvent.key      = key-->
  <!--setItemEvent.newValue = newValue-->
  <!--window.dispatchEvent(setItemEvent)-->
  <!--orignalSetItem.apply(this, arguments)-->
  <!--}-->
  <!--</script>-->
  <script>
    // 同一个页面 不能监听?? 那单页应用不得废了?
    // window.addEventListener('storage', function (e) {
    //   alert(e.newValue)
    // })
    var oldSetItem              = window.localStorage.setItem
    window.localStorage.setItem = function (k, v) {
      // if (k === '你要监听的key') {/* 执行你的逻辑*/}
      oldSetItem.apply(window.localStorage, [k, v])
    }
  </script>

  <link rel="stylesheet" href="static/css/mui.min.css">

  <script src="static/js/mui.min.js"></script>
  <!--<script src="static/js/update.js" type="text/javascript" charset="utf-8"></script>-->
</head>
<!--
  oncontextmenu 事件在元素中用户右击鼠标时触发并打开上下文菜单。
  onselectstart
    使用js禁止用户选中网页上的内容，IE及Chrome下的方法一样。
    使用onselectstart，例如
    IE: <body onselectstart="return false">
    Firefox：，控制css: body { -moz-user-select: none; }       
    onselectstart几乎可以用于所有对象，其触发时间为目标对象被开始选中时（即选中动作刚开始，尚未实质性被选中）。
    该事件常使用 于使目标对象“禁止变蓝”，
    比如在很多地方当用户双击时，一些元素会变成蓝色（选中状态）， 而当我们要避免这种情况时就可以使用该事件
  onselect 事件会在文本框中的文本被选中时发生。
  oncopy 事件在用户拷贝元素上的内容时触发。
  oncut 事件在用户剪切元素的内容时触发。
-->

<body oncontextmenu="return false" onselectstart="return false" onselect="return false" oncopy="return false" oncut="return false">
  <div id="app"></div>

  <!--
    https://www.cnblogs.com/mmzuo-798/p/9299138.html
    localStorage 居然能使用点语法, 一直都不知道 fuck
    删除属性 还能用 delete localStorage.name
  -->
  <!--<script type="text/javascript">-->
  <!--setInterval(function () {-->
  <!--var r     = Math.floor(Math.random() * 255)-->
  <!--var g     = Math.floor(Math.random() * 255)-->
  <!--var b     = Math.floor(Math.random() * 255)-->
  <!--let value = 'rgb(' + r + ', ' + g + ', ' + b + ')'-->
  <!--window.localStorage.setItem('name', value)-->
  <!--// window.localStorage.name = value;-->
  <!--console.log('【index.html:100】-:', Reflect.ownKeys(window.localStorage));-->
  <!--}, 2000)-->
  <!--</script>-->
</body>
</html>




